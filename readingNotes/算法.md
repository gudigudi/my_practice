## 1. 基础编程模型

### 递归
编写递归代码时最重要的有以下三点:
* 递归总有一个最简单的情况----方法的第一条语句总是一个包含return的条件语句。

在下面的代码中，第四个参数和第三个参数的差值一直在缩小。
* 递归调用的父问题和尝试解决的子问题之间不应该有交集。

---

### 你自己编写的库
你应该将自己编写的每一个程序都当做一个日后可以重用的库。
* 编写用例，在实现中将计算过程分解成可控的部分。
* 明确静态方法库和与之对应的API(或者多个库的多个API)。
* 实现API和一个能够对方法进行独立测试的main()函数。
这个方法不仅能帮助你实现可重用的代码，而且能够教会你如何运用模块化编程来解决一
个复杂的问题。

---

### 科学方法
科学家用来理解自然世界的方法对于研究计算机程序的运行时间同样有效:
* 细致地观察真实世界的特点，通常还要有精确的测量；
* 根据观察结果提出假设模型；
* 根据模型预测未来的事件；
* 继续观察并核实预测的准确性；
* 如此反复直到确认预测和观察一致。
科学方法的一条关键原则是我们所设计的实验必须是__可重现__的，这样他人也可以自己验证
假设的真实性。所有的假设也必须的__可证伪_的，这样我们才能确认某个假设是错误的(并需
要修正)。

我们永远也没法知道某个假设是否绝对正确，我们只能验证它和我们的观察的一致性。

---

算法分析中的常见函数

| 描述                | 记号                    | 定义                    |
| ------------------- | ----------------------- | ----------------------- |
| 向下取整(floor)     | &lfloor;x&rfloor;       | 不大于x的最大整数       |
| 向上取整(ceiling)   | &lceil;x&rceil;         | 不小于x的最小整数       |
| 自然对数            | lnN                     | log<sub>e</sub>N\(e<sup>x</sup>=N\) |
| 以2为底的对数       | lgN                     | log<sub>2</sub>N\(2<sup>x</sup>=N\) |
| 以2为底的整型对数   | &lfloor;lgN&rfloor;     | 不大于lgN的最大整数     |
| 调和级数            | H<sub>N</sub>           | 1+1/2+1/3+...+1/N       |
| 阶乘                | N!                      | 1×2×3×4...×N            |


### union-find算法
设计和分析算法的基本方法，要强调:
* 优秀的算法因为能够解决实际问题而变得更为重要；
* 高效算法的代码也可以很简单；
* 理解某个实现的性能特点是一项有趣而令人满足的挑战；
* 在解决同一个问题的多种算法之间进行选择时，科学方法是一种重要的工具；
* 迭代式改进能够让算法的效率越来越高。


